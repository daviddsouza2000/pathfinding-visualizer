{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","algorithms/bfs.js","algorithms/dfs.js","algorithms/astar.js","mazes/backtrackingDfs.js","mazes/prim.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","col","isFinish","isStart","isWall","onMouseDown","isVisited","onMouseEnter","onMouseUp","row","extraClassName","id","className","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","getNeighbors","open","closed","calculateDistance","node1","node2","Math","abs","backtracking","stack","choices","rnd","floor","random","inBetween","frontier","pop","i","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","GRID_ROWS","GRID_COLS","PathfindingVisualizer","useState","setGrid","mouseIsPressed","setMouseIsPressed","canDraw","setCanDraw","movingStartNode","setMovingStartNode","movingFinishNode","setMovingFinishNode","gridRows","setGridRows","gridCols","setGridCols","useEffect","newGrid","getInitialGrid","animateShortestPath","nodesInShortestPathOrder","setTimeout","document","getElementById","classList","add","visualizeAlgorithm","algorithm","queue","currentNode","bfs","dfs","fValue","console","log","current","includes","astar","animateAlgorithm","unshift","getNodesInShortestPathOrder","generateMaze","getInitialGridWithAllWalls","lst","splice","primMaze","animateMaze","newGrid2","getNewGridWithFinishNodeToggled","remove","clearGrid","clearWalls","getInitialGridWithWalls","onClick","for","type","min","max","value","step","onChange","event","newRowNum","target","getNewGridWithRowsToggled","newColNum","getNewGridWithColsToggled","map","rowIdx","nodeIdx","getNewGridWithWallToggled","handleMouseDown","getNewGridWithStartNodeToggled","handleMouseEnter","currentRow","createNode","slice","newNode","newNode2","nodeIsWall","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.6e578d6b.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default function Node({ col, isFinish, isStart, isWall, isVisited, onMouseDown, onMouseEnter, onMouseUp, row}) {\r\n    const extraClassName = isFinish \r\n        ? 'node-finish' \r\n        : isStart \r\n            ? 'node-start'\r\n            : isWall\r\n                ? 'node-wall'\r\n                // : isVisited\r\n                //     ? 'node-visited'\r\n                    : '';\r\n    return (\r\n        <div\r\n            id={`node-${row}-${col}`}\r\n            className={`node ${extraClassName}`}\r\n            onMouseDown={() => onMouseDown(row, col)}\r\n            onMouseEnter={() => onMouseEnter(row, col)}\r\n            onMouseUp={() => onMouseUp()}></div>\r\n    );\r\n}","// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    while (!!unvisitedNodes.length) {\r\n        sortNodesByDistance(unvisitedNodes);\r\n        const closestNode = unvisitedNodes.shift();\r\n        // If we encounter a wall, we skip it.\r\n        if (closestNode.isWall) continue;\r\n        // If the closest node is at a distance of infinity,\r\n        // we must be trapped and should therefore stop.\r\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n        closestNode.isVisited = true;\r\n        visitedNodesInOrder.push(closestNode);\r\n        if (closestNode === finishNode) return visitedNodesInOrder;\r\n        updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        neighbor.distance = node.distance + 1;\r\n        neighbor.previousNode = node;\r\n    }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n","export function bfs(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    const queue = [];\r\n    queue.push(startNode);\r\n\r\n    while (queue.length) {\r\n        const currentNode = queue.shift();\r\n        \r\n        if (currentNode.isWall) continue;\r\n        \r\n        if(currentNode.isVisited) continue; \r\n\r\n        visitedNodesInOrder.push(currentNode);\r\n        currentNode.isVisited = true;\r\n\r\n        if (currentNode === finishNode) return visitedNodesInOrder;\r\n        \r\n        const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            neighbor.previousNode = currentNode;\r\n        }\r\n        queue.push(...unvisitedNeighbors);\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}","export function dfs(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    const stack = [];\r\n    stack.push(startNode);\r\n\r\n    while (stack.length) {\r\n        const currentNode = stack.pop();\r\n        \r\n        if (currentNode.isWall) continue;\r\n        \r\n        if(currentNode.isVisited) continue; \r\n\r\n        visitedNodesInOrder.push(currentNode);\r\n        currentNode.isVisited = true;\r\n\r\n        if (currentNode === finishNode) return visitedNodesInOrder;\r\n        \r\n        const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\r\n        for (const neighbor of unvisitedNeighbors) {\r\n            neighbor.previousNode = currentNode;\r\n        }\r\n        stack.push(...unvisitedNeighbors);\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}","export function astar(grid, startNode, finishNode){\r\n    const visitedNodesInOrder = [];\r\n    \r\n    // nodes to be evaluted\r\n    const open = [];\r\n    // nodes already evaluated\r\n    const closed = [];\r\n    \r\n    startNode.fValue = calculateDistance(startNode, finishNode);\r\n    open.push(startNode);\r\n    while(open.length){\r\n        console.log(visitedNodesInOrder);\r\n        const current = open.shift();\r\n\r\n        if(current.isVisited) continue; \r\n\r\n        visitedNodesInOrder.push(current);\r\n        current.isVisited = true;\r\n\r\n        if (current === finishNode) return visitedNodesInOrder;\r\n\r\n        const neighbors = getNeighbors(grid, current, open, closed);\r\n\r\n        for(const neighbor of neighbors){\r\n            if(!open.includes(neighbor) && !open.includes(neighbor)){\r\n                open.push(neighbor);\r\n                const fValue = calculateDistance(startNode, neighbor) + calculateDistance(neighbor, finishNode);\r\n                if(neighbor.fValue){\r\n                    if (fValue < neighbor.fValue){\r\n                        neighbor.fValue = fValue;\r\n                        neighbor.previousNode = current;\r\n                    }\r\n                } else {\r\n                    neighbor.fValue = fValue;\r\n                    neighbor.previousNode = current;\r\n                }\r\n            }\r\n        }\r\n        closed.push(current);\r\n        sortNodesByDistance(open);\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.fValue - nodeB.fValue);\r\n}\r\n\r\nfunction getNeighbors(grid, node, open, closed) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter((neighbor) => !neighbor.isWall);\r\n    \r\n}\r\n\r\nfunction calculateDistance(node1, node2) {\r\n    return Math.abs(node1.col - node2.col) + Math.abs(node1.row - node2.row);\r\n}","export function backtracking(grid, startNode) {\r\n    const visitedNodesInOrder = [];\r\n    const stack = [];\r\n\r\n    startNode.isWall = false;\r\n    visitedNodesInOrder.push(startNode);\r\n    const choices = [[-2,0],[0,2],[2,0],[0,-2]];\r\n    let neighbors = getUnvisitedNeighbors(startNode, grid , choices);\r\n    \r\n    let rnd = Math.floor(Math.random () * neighbors.length);\r\n    stack.push(neighbors[rnd]);\r\n\r\n    while (stack.length) {\r\n        let [inBetween, frontier] = stack[stack.length - 1];\r\n        frontier.isWall = false;\r\n        visitedNodesInOrder.push(frontier);\r\n        \r\n        inBetween.isWall = false;\r\n        visitedNodesInOrder.push(inBetween);\r\n        neighbors = getUnvisitedNeighbors(frontier,grid,choices);\r\n        if(neighbors.length){\r\n            rnd = Math.floor(Math.random () * neighbors.length);\r\n            stack.push(neighbors[rnd]);\r\n        } else{\r\n            stack.pop();\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid, choices) {\r\n    const neighbors = [];\r\n    for(let i = 0 ; i < choices.length ; i++){\r\n        let row = node.row + choices[i][0];\r\n        let col = node.col + choices[i][1];\r\n        if(grid[row] && grid[row][col] && grid[row][col].isWall){\r\n            let frontier = grid[row][col];\r\n            let inBetween = null;\r\n            if(choices[i][0] === -2){\r\n              inBetween = grid[node.row-1][node.col];\r\n            }else if(choices[i][0] === 2){\r\n              inBetween = grid[node.row+1][node.col];\r\n            }else if(choices[i][1] === -2){\r\n              inBetween = grid[node.row][node.col - 1];\r\n            }else if(choices[i][1] === 2){\r\n              inBetween = grid[node.row][node.col + 1];\r\n            }\r\n            neighbors.push([inBetween, frontier]);\r\n        }\r\n    }\r\n    return neighbors;\r\n\r\n}","export function primMaze(grid, startNode) {\r\n    const visitedNodesInOrder = [];\r\n    const lst = [];\r\n\r\n    startNode.isWall = false;\r\n    visitedNodesInOrder.push(startNode);\r\n    const choices = [[-2,0],[0,2],[2,0],[0,-2]];\r\n    let neighbors = getUnvisitedNeighbors(startNode, grid , choices);\r\n    lst.push(...neighbors);\r\n\r\n    while (lst.length) {\r\n        let rnd = Math.floor(Math.random() * lst.length);\r\n        let [inBetween, frontier] = lst[rnd];\r\n        lst.splice(rnd,1);\r\n\r\n        if(frontier.isWall){\r\n            frontier.isWall = false;\r\n            inBetween.isWall = false;\r\n            visitedNodesInOrder.push(inBetween);\r\n            visitedNodesInOrder.push(frontier);\r\n            neighbors = getUnvisitedNeighbors(frontier, grid, choices);\r\n            lst.push(...neighbors);\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid, choices) {\r\n    const neighbors = [];\r\n    for(let i = 0 ; i < choices.length ; i++){\r\n        let row = node.row + choices[i][0];\r\n        let col = node.col + choices[i][1];\r\n        if(grid[row] && grid[row][col] && grid[row][col].isWall){\r\n            let frontier = grid[row][col];\r\n            let inBetween = null;\r\n            if(choices[i][0] === -2){\r\n              inBetween = grid[node.row-1][node.col];\r\n            }else if(choices[i][0] === 2){\r\n              inBetween = grid[node.row+1][node.col];\r\n            }else if(choices[i][1] === -2){\r\n              inBetween = grid[node.row][node.col - 1];\r\n            }else if(choices[i][1] === 2){\r\n              inBetween = grid[node.row][node.col + 1];\r\n            }\r\n            neighbors.push([inBetween, frontier]);\r\n        }\r\n    }\r\n    return neighbors;\r\n\r\n}","import React, { useState, useEffect } from 'react';\r\nimport Node from './Node/Node';\r\nimport { dijkstra, getNodesInShortestPathOrder } from '../algorithms/dijkstra';\r\nimport { bfs } from '../algorithms/bfs';\r\nimport { dfs } from '../algorithms/dfs';\r\nimport { astar } from '../algorithms/astar';\r\nimport { backtracking } from '../mazes/backtrackingDfs';\r\nimport { primMaze } from '../mazes/prim';\r\n\r\nimport './PathfindingVisualizer.css';\r\n\r\nvar START_NODE_ROW = 8;\r\nvar START_NODE_COL = 15;\r\nvar FINISH_NODE_ROW = 10;\r\nvar FINISH_NODE_COL = 35;\r\n\r\nvar GRID_ROWS = 20;\r\nvar GRID_COLS = 40;\r\n\r\nexport default function PathfindingVisualizer() {\r\n    const [grid, setGrid] = useState([]);\r\n    const [mouseIsPressed, setMouseIsPressed] = useState(false);\r\n    const [canDraw, setCanDraw] = useState(true); // true if visualizer is run/ already ran to disable creating walls\r\n    const [movingStartNode, setMovingStartNode] = useState(false); // if user is moving start node\r\n    const [movingFinishNode, setMovingFinishNode] = useState(false); // if user is moving finish node\r\n    const [gridRows, setGridRows] = useState(20);\r\n    const [gridCols, setGridCols] = useState(40);\r\n\r\n    useEffect(() => {\r\n        const newGrid = getInitialGrid();\r\n        setGrid(newGrid);\r\n    }, []);\r\n\r\n    const handleMouseDown = (row, col) => {\r\n        if(!canDraw) return;\r\n\r\n        if (row === START_NODE_ROW && col === START_NODE_COL) {\r\n            setMovingStartNode(true);\r\n        }\r\n        else if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL) {\r\n            setMovingFinishNode(true);\r\n        }\r\n        else {\r\n            const newGrid = getNewGridWithWallToggled(grid, row, col);\r\n            setGrid(newGrid);\r\n        }\r\n        setMouseIsPressed(true);\r\n    }\r\n\r\n    const handleMouseEnter = (row, col) => {\r\n        if (!canDraw) return;\r\n        if (!mouseIsPressed) return;\r\n\r\n        if (movingStartNode) {\r\n            const newGrid = getNewGridWithStartNodeToggled(grid, row, col);\r\n            setGrid(newGrid);\r\n        }\r\n        else if (movingFinishNode) {\r\n            const newGrid = getNewGridWithFinishNodeToggled(grid, row, col);\r\n            setGrid(newGrid);\r\n        }\r\n        else {\r\n            const newGrid = getNewGridWithWallToggled(grid, row, col);\r\n            setGrid(newGrid);\r\n        }\r\n    }\r\n\r\n    const handleMouseUp = () => {\r\n        setMovingStartNode(false);\r\n        setMovingFinishNode(false);\r\n        setMouseIsPressed(false);\r\n    }\r\n\r\n    const animateAlgorithm = (visitedNodesInOrder, nodesInShortestPathOrder) => {\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            if (i === visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                    animateShortestPath(nodesInShortestPathOrder);\r\n                }, 10 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).classList.add('node-visited');\r\n            }, 10 * i);\r\n        }\r\n    }\r\n\r\n    const animateShortestPath = (nodesInShortestPathOrder) => {\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n            setTimeout(() => {\r\n                const node = nodesInShortestPathOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).classList.add('node-shortest-path');\r\n            }, 50 * i);\r\n        }\r\n    }\r\n\r\n    const visualizeAlgorithm = (algorithm) => {\r\n        if(!canDraw) return;\r\n        setCanDraw(false);\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        \r\n        var visitedNodesInOrder;\r\n        switch(algorithm){\r\n            case \"dijkstra\":\r\n                visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n                break;\r\n            case \"bfs\":\r\n                visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n                break;\r\n            case \"dfs\":\r\n                visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n                break;\r\n            case \"astar\":\r\n                visitedNodesInOrder = astar(grid, startNode, finishNode);\r\n                break;\r\n            default:\r\n                visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n                break;\r\n        }\r\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n        animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }\r\n\r\n    const generateMaze = (algorithm) => {\r\n        if(!canDraw) return;\r\n        setCanDraw(false);\r\n        const newGrid = getInitialGridWithAllWalls(grid);\r\n        for (let row = 0; row < GRID_ROWS; row++) {\r\n            for (let col = 0; col < GRID_COLS; col++) {\r\n                const node = document.getElementById(`node-${row}-${col}`);\r\n                node.classList.add('node-wall');\r\n            }\r\n        }\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n\r\n        var visitedNodesInOrder;\r\n        switch(algorithm){\r\n            case \"backtracking\":\r\n                visitedNodesInOrder = backtracking(newGrid, startNode);\r\n                break;\r\n            case \"prim\":\r\n                visitedNodesInOrder = primMaze(newGrid, startNode);\r\n                break;\r\n            default:\r\n                visitedNodesInOrder = backtracking(newGrid, startNode);\r\n        }\r\n        animateMaze(visitedNodesInOrder);\r\n    }\r\n\r\n    const animateMaze = (visitedNodesInOrder) => {\r\n        const newGrid = getInitialGridWithAllWalls(grid);\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            if (i === visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                    const { row, col } = visitedNodesInOrder[Math.floor(Math.random() * visitedNodesInOrder.length)];\r\n                    const newGrid2 = getNewGridWithFinishNodeToggled(newGrid, row, col);\r\n                    setGrid(newGrid2);\r\n                    setCanDraw(true);\r\n                }, 10 * (i+1));\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).classList.remove('node-wall');\r\n                newGrid[node.row][node.col].isWall = false;\r\n            }, 10 * i);\r\n        }\r\n    }\r\n\r\n\r\n    const clearGrid = (clearWalls=false) => {\r\n        setCanDraw(true);\r\n        const newGrid = clearWalls ? getInitialGrid() : getInitialGridWithWalls(grid);\r\n        setGrid(newGrid);\r\n        for (let row = 0; row < GRID_ROWS; row++) {\r\n            for (let col = 0; col < GRID_COLS; col++) {\r\n                const node = document.getElementById(`node-${row}-${col}`);\r\n                node.classList.remove('node-visited');\r\n                node.classList.remove('node-shortest-path');\r\n            }\r\n        }\r\n    }\r\n\r\n    const handleRowSlider = (event) => {\r\n        if(!canDraw) return;\r\n        clearGrid(true);\r\n        const newRowNum = event.target.value\r\n        setGridRows(newRowNum);\r\n        const newGrid = getNewGridWithRowsToggled(newRowNum);\r\n        setGrid(newGrid);\r\n    }\r\n\r\n    const handleColSlider = (event) => {\r\n        if(!canDraw) return;\r\n        clearGrid(true);\r\n        const newColNum = event.target.value\r\n        setGridCols(newColNum);\r\n        const newGrid = getNewGridWithColsToggled(newColNum);\r\n        setGrid(newGrid);\r\n    }\r\n\r\n    return (\r\n        <>\r\n            <nav className=\"navbar\">\r\n                <div className=\"dropdown\">\r\n                    <button className=\"dropbtn\">Visualize Pathfinding Algorithm  \r\n                    <i className=\"fa fa-caret-down\"></i>\r\n                    </button>\r\n                    <div className=\"dropdown-content\">\r\n                        <button onClick={() => visualizeAlgorithm(\"dijkstra\")}>\r\n                            Dijkstra's Algorithm\r\n                        </button>\r\n                        <button onClick={() => visualizeAlgorithm(\"bfs\")}>\r\n                            Breadth First Search\r\n                        </button>\r\n                        <button onClick={() => visualizeAlgorithm(\"dfs\")}>\r\n                            Depth First Search\r\n                        </button>\r\n                        <button onClick={() => visualizeAlgorithm(\"astar\")}>\r\n                            A* Algorithm\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n                <div className=\"dropdown\">\r\n                    <button className=\"dropbtn\">Maze Generation Algorithm  \r\n                    <i className=\"fa fa-caret-down\"></i>\r\n                    </button>\r\n                    <div className=\"dropdown-content\">\r\n                        <button onClick={() => generateMaze(\"backtracking\")}>\r\n                            Recursive Backtracking\r\n                        </button>\r\n                        <button onClick={() => generateMaze(\"prim\")}>\r\n                            Randomized Prim's Algorithm\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n                <button className=\"clearButton\" onClick={() => clearGrid()}>Clear Path</button>\r\n                <button className=\"clearButton\" onClick={() => clearGrid(true)}>Clear Path and Walls</button>\r\n                <div className=\"sliders-div\">\r\n                    <label for=\"gridRows\">Rows: {gridRows} </label>\r\n                    <input id=\"gridRows\" type=\"range\" min=\"5\" max=\"30\" value={gridRows} step=\"1\" onChange={handleRowSlider}/>\r\n                    <label for=\"gridCols\">Columns: {gridCols} </label>\r\n                    <input id=\"gridCols\" type=\"range\" min=\"5\" max=\"60\" value={gridCols} step=\"1\" onChange={handleColSlider}/>\r\n                </div>\r\n            </nav>\r\n            <br />\r\n\r\n            <div className=\"grid\">\r\n                {grid.map((row, rowIdx) => {\r\n                    return (\r\n                        <div key={rowIdx}>\r\n                            {row.map((node, nodeIdx) => {\r\n                                const { row, col, isFinish, isStart, isWall, isVisited } = node;\r\n                                return (\r\n                                    <Node\r\n                                        key={nodeIdx}\r\n                                        col={col}\r\n                                        isFinish={isFinish}\r\n                                        isStart={isStart}\r\n                                        isWall={isWall}\r\n                                        isVisited={isVisited}\r\n                                        mouseIsPressed={mouseIsPressed}\r\n                                        onMouseDown={(row, col) => handleMouseDown(row, col)}\r\n                                        onMouseEnter={(row, col) =>\r\n                                            handleMouseEnter(row, col)\r\n                                        }\r\n                                        onMouseUp={() => handleMouseUp()}\r\n                                        row={row}></Node>\r\n                                );\r\n                            })}\r\n                        </div>\r\n                    );\r\n                })}\r\n            </div>\r\n        </>\r\n    );\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n    const grid = [];\r\n    for (let row = 0; row < GRID_ROWS; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < GRID_COLS; col++) {\r\n            currentRow.push(createNode(col, row));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n};\r\n\r\nconst createNode = (col, row, isWall = false) => {\r\n    return {\r\n        col,\r\n        row,\r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isWall,\r\n        previousNode: null,\r\n    };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n};\r\n\r\nconst getNewGridWithStartNodeToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[START_NODE_ROW][START_NODE_COL];\r\n    const newNode = {\r\n        ...node,\r\n        isStart: false,\r\n    };\r\n    newGrid[START_NODE_ROW][START_NODE_COL] = newNode;\r\n\r\n    START_NODE_COL = col;\r\n    START_NODE_ROW = row;\r\n\r\n    const node2 = newGrid[START_NODE_ROW][START_NODE_COL];\r\n    const newNode2 = {\r\n        ...node2,\r\n        isStart: true,\r\n        isWall: false,\r\n    };\r\n    newGrid[START_NODE_ROW][START_NODE_COL] = newNode2;\r\n\r\n    return newGrid;\r\n}\r\n\r\nconst getNewGridWithFinishNodeToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const newNode = {\r\n        ...node,\r\n        isFinish: false,\r\n    };\r\n    newGrid[FINISH_NODE_ROW][FINISH_NODE_COL] = newNode;\r\n\r\n    FINISH_NODE_COL = col;\r\n    FINISH_NODE_ROW = row;\r\n\r\n    const node2 = newGrid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const newNode2 = {\r\n        ...node2,\r\n        isFinish: true,\r\n        isWall: false,\r\n    };\r\n    newGrid[FINISH_NODE_ROW][FINISH_NODE_COL] = newNode2;\r\n\r\n    return newGrid;\r\n}\r\n\r\nconst getInitialGridWithWalls = (grid) => {\r\n    const newGrid = [];\r\n    var nodeIsWall = false;\r\n    for (let row = 0; row < GRID_ROWS; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < GRID_COLS; col++) {\r\n            nodeIsWall = grid[row][col].isWall\r\n            currentRow.push(createNode(col, row, nodeIsWall));\r\n        }\r\n        newGrid.push(currentRow);\r\n    }\r\n    return newGrid;\r\n};\r\n\r\nconst getInitialGridWithAllWalls = (grid) => {\r\n    const newGrid = [];\r\n    for (let row = 0; row < GRID_ROWS; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < GRID_COLS; col++) {\r\n            currentRow.push(createNode(col, row, true));\r\n        }\r\n        newGrid.push(currentRow);\r\n    }\r\n    return newGrid;\r\n};\r\n\r\nconst getNewGridWithRowsToggled = (newRowNum) => {\r\n    if (START_NODE_ROW >= newRowNum){\r\n        START_NODE_ROW = newRowNum-1;\r\n    }\r\n    if (FINISH_NODE_ROW >= newRowNum){\r\n        FINISH_NODE_ROW = newRowNum-1;\r\n    }\r\n    GRID_ROWS = newRowNum;\r\n    const newGrid = getInitialGrid();\r\n    return newGrid;\r\n}\r\n\r\nconst getNewGridWithColsToggled = (newColNum) => {\r\n    if (START_NODE_COL >= newColNum){\r\n        START_NODE_COL = newColNum-1;\r\n    }\r\n    if (FINISH_NODE_COL >= newColNum){\r\n        FINISH_NODE_COL = newColNum-1;\r\n    }\r\n    GRID_COLS = newColNum;\r\n    const newGrid = getInitialGrid();\r\n    return newGrid;\r\n}","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}